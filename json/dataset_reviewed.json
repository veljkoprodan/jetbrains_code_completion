[{"prefix": "   # ### Crossover\ndef precedence_preservative_crossover(parent1, parent2, child1, child2):\n    chosen_parent1 = random.choices([1, 2], k=len(parent1.code))\n    chosen_parent2 = [2 if x == 1 else 1 for x in chosen_parent1]\n    p1 = deepcopy(parent1.code)\n    p2 = deepcopy(parent2.code)\n    p12 = deepcopy(p1)\n    p22 = deepcopy(p2)\n    for i, num in enumerate(chosen_parent1):\n        if num == 1:\n            child1.code[i] = p1[0]\n            p2.remove(p1[0])\n            p1.pop(0)\n        elif num == 2:\n            child1.code[i] = p2[0]\n            p1.remove(p2[0])\n            p2.pop(0)", "middle": "    for i, num in enumerate(chosen_parent2):\n        if num == 1:\n            child2.code[i] = p12[0]", "suffix": "            p22.remove(p12[0])\n            p12.pop(0)\n        elif num == 2:\n            child2.code[i] = p22[0]\n            p12.remove(p22[0])\n            p22.pop(0)", "middle_predicted": "\n            p12.append(p1[0])\n        else:\n            raise ValueError(\"Invalid number\")\n\n    for i, num in enumerate(chosen_parent2):\n        if num == 1:\n            child2.code[i] = p12[0]\n    ", "review_label": 3, "comment": "Last three lines are completely correct, but first three lines don't make sense in this context"}, {"prefix": "#include \"Serializer.h\"\n#include <QJsonDocument>\n#include <QFile>\nvoid Serializer::save(const Serializable &serializable, const QString &filepath)\n{\n    QJsonDocument doc = QJsonDocument::fromVariant(serializable.toVariant());", "middle": "    QFile file(filepath);\n    file.open(QFile::WriteOnly);", "suffix": "    file.write(doc.toJson(QJsonDocument::JsonFormat::Indented));\n    file.close();\n}\nvoid Serializer::load(Serializable &serializable, const QString &filepath)\n{\n    QFile file(filepath);\n    if(!file.exists()){\n        return;\n    }\n    file.open(QFile::ReadOnly);\n    QJsonDocument doc = QJsonDocument::fromJson(file.readAll());\n    file.close();\n    serializable.fromVariant(doc.toVariant());\n}", "middle_predicted": "\n    doc.setFilePath(filepath);\n}\nvoid Serializer::loadFromFile(Serializable &serializable, const QString &filepath)\n{\n    QFile file(filepath);\n    if (!file.exists){\n        return;\n    }\n    file.open(QFile::ReadOnly);\n    QJsonDocument doc = QJsonDocument::fromJson(file.readAll());\n    file.close();\n    serializable.fromVariant(doc.toVariant());\n}\nvoid Serializer::saveToFile(Serializable &serializable, const QString &filepath)\n{\n    QFile file(filepath);\n    if (!file.exists){\n        return;\n    }\n    file.open(QFile::WriteOnly);\n   ", "review_label": "1", "comment": "/"}, {"prefix": "GeocodingAPI::GeocodingAPI()\n{\n    const QString configFilePath = QCoreApplication::applicationDirPath() + \"/config.ini\";\n    const QSettings settings(configFilePath, QSettings::IniFormat);\n    OPEN_CAGE_API_KEY = settings.value(\"API/Key\").toString();\n    connect(networkManager, &QNetworkAccessManager::finished, this, &GeocodingAPI::replyFinished);\n}\nvoid GeocodingAPI::geocodeCity(const QString& location)\n{\n    QString apiUrl = QString(\"https://api.opencagedata.com/geocode/v1/json?q=%1&key=%2\")\n                    .arg(location, OPEN_CAGE_API_KEY);", "middle": "    QNetworkRequest request{QUrl(apiUrl)};\n", "suffix": "    networkManager->get(request);\n}", "middle_predicted": ";\n    return geocode(apiUrl).toXML();\n}\nvoid GeocodingAPI::geocodeCountry(const QString& country)\n{\n    QString apiUrl = QString(\"https://api.opencagedata.com/geocode/v1/json?q=%1&key=%2\")\n                   .arg(country, OPEN_CAGE_API_KEY);;\n    return geocode(apiUrl).toXML();\n}\nvoid GeocodingAPI::geocodePostalCode(const QString& postalCode)\n{\n    QString apiUrl = QString(\"https://api.opencagedata.com/geocode/v1/json?q=%1&key=%2", "review_label": "1", "comment": "/"}, {"prefix": "def equations_of_motion(y):\n    r1, r2, r3 = y[0:2], y[2:4], y[4:6]\n    v1, v2, v3 = y[6:8], y[8:10], y[10:12]\n    r12 = np.linalg.norm(r2 - r1)\n    r13 = np.linalg.norm(r3 - r1)\n    r23 = np.linalg.norm(r3 - r2)\n    r1_pp = G * (r2 - r1) / r12**3 + G * (r3 - r1) / r13**3\n    r2_pp = G * (r1 - r2) / r12**3 + G * (r3 - r2) / r23**3\n    r3_pp = G * (r1 - r3) / r13**3 + G * (r2 - r3) / r23**3\n    return np.concatenate((v1, v2, v3, r1_pp, r2_pp, r3_pp))\ndef calculate_energy(y):\n    r1, r2, r3 = y[0:2], y[2:4], y[4:6]\n    v1, v2, v3 = y[6:8], y[8:10], y[10:12]\n    # Kinetic energy\n    KE = 0.5 * (m1 * np.dot(v1, v1) + m2 * np.dot(v2, v2) + m3 * np.dot(v3, v3))\n    # Potential energy\n    r12 = np.linalg.norm(r2 - r1)\n    r13 = np.linalg.norm(r3 - r1)", "middle": "    r23 = np.linalg.norm(r3 - r2)", "suffix": "    PE = -G * (m1 * m2 / r12 + m1 * m3 / r13 + m2 * m3 / r23)\n    return KE + PE", "middle_predicted": "\n    r23 = np.linalg.norm(r3 - r2)\n    r1_pp = G * (r2 - r1) / r12**3 + G * (r3 - r1) / r13**3\n    r2_pp = G * (r1 - r2) / r12**3 + G * (r3 - r2) / r23**3\n    r3_pp = G * (r1 - r3) / r13**3 + G * (r2 - r3) / r23**3\n    return KE + PE\n\n\ndef calculate_kinetic_energy(", "review_label": "2", "comment": "The first line matches perfectly with the actual code, but the next three lines are identical to a part of prefix code"}, {"prefix": "#include \"UserLocation.h\"\n#include \"GeoLocationData.h\"\n#include \"Settings.h\"\nUserLocation::UserLocation(QObject *parent)\n    : QObject{parent}\n    , source(QGeoPositionInfoSource::createDefaultSource(this))\n{\n    if(source != nullptr){\n        connect(source, &QGeoPositionInfoSource::positionUpdated, this, &UserLocation::positionUpdated);\n        connect(source, &QGeoPositionInfoSource::errorOccurred, this, &UserLocation::handleError);", "middle": "    }", "suffix": "}\nvoid UserLocation::getLocation()\n{\n    if(source == nullptr){\n        emit userLocationError(errMsg);\n    }\n    else{\n        source->requestUpdate();\n    }\n}\nvoid UserLocation::positionUpdated(const QGeoPositionInfo &info)\n{\n    // positionUpdated signal is emitted twice (?) so we check if it's the first time\n    if(!userLocationRequested){\n        userLocationRequested = true;\n        GeoLocationData data = GeoLocationData(\"My location\", info.coordinate());\n        emit userLocationFetched(data);\n    }\n}\nvoid UserLocation::handleError(const QGeoPositionInfoSource::Error)\n{\n    emit userLocationError(errMsg);\n}", "middle_predicted": "\n    }else{\n        source->requestUpdate();\n    }\n}\nvoid UserLocation::handleError(const QGeoPositionInfoSource::Error)\n{\n    emit userLocationError(errMsg);\n", "review_label": "1", "comment": "/"}, {"prefix": "WeatherAPI::WeatherAPI(QObject *parent)\n    : ApiHandler{parent}\n{\n    connect(networkManager, &QNetworkAccessManager::finished, this, &WeatherAPI::replyFinished);\n}\nvoid WeatherAPI::fetchData(const GeoLocationData &location)\n{\n    QString latitude  = QString::number(location.getCoordinates().latitude());\n    QString longitude = QString::number(location.getCoordinates().longitude());\n    QUrl url(\"https://api.open-meteo.com/v1/forecast\");\n    QUrlQuery query;", "middle": "    query.addQueryItem(\"latitude\", latitude);\n    query.addQueryItem(\"longitude\", longitude);", "suffix": "    query.addQueryItem(\"current\", \"temperature_2m,weather_code,is_day\");\n    query.addQueryItem(\"daily\", \"temperature_2m_max,temperature_2m_min\");\n    query.addQueryItem(\"timezone\", \"auto\");\n    query.addQueryItem(\"temperature_unit\", Settings::instance().temperatureUnitApiParameter());\n    url.setQuery(query);\n    QNetworkRequest request(url);\n    auto *reply = networkManager->get(request);\n    reply->setProperty(\"location\", location.toVariant());\n    connect(reply, &QNetworkReply::errorOccurred, this, [this](){\n        emit errorOccurred(networkErrMsg);\n    });\n}", "middle_predicted": ";\n    QNetworkRequest request(QUrlQuery &query);\n    QNetworkReply reply = networkManager->get(request);\n    if (reply == null || reply.status() == QNetworkStatus.OK){\n        return false;\n    } else {\n    ", "review_label": "1", "comment": "/"}, {"prefix": "void DetailedWeatherPage::setData(const QSharedPointer<DetailedWeatherData> detailedData){\n    this->data = detailedData;\n    highlightWidget();\n    locationInfo->updateData(this->data->location().getCoordinates(),\n                             this->data->location().getRenamedPlace(),", "middle": "                             this->data->location().getDetailedPlace());\n    basicInfo->updateData(this->data->weatherCode(), this->data->isDay(), this->data->timezone(),\n                          this->data->temperature(), this->data->apparentTemperature());", "suffix": "    minmaxWidget->updateData(this->data->weeklyMaxTemp(), this->data->weeklyMinTemp(),\n                             this->data->weeklyDayName());\n    sunWidget->updateData(this->data->timezone(), this->data->sunrise(), this->data->sunset());\n    hourlyWidget->updateData(this->data->hourlyTemperature(), this->data->hourlyCode(),\n                             this->data->hourlyIsDay(), this->data->hourlyTimeStamp());\n    dailyWidget->updateData(this->data->weeklyDayName(), this->data->weeklyCode(),\n                            this->data->weeklyMinTemp(), this->data->weeklyMaxTemp(),\n                            this->data->fullHourlyTemperature());\n    emit detailedDataFetched();\n}", "middle_predicted": " this->data->location().getLatitude(),\n                             this->data->location().getLongitude(),\n                             this->data->location().getAltitude(),\n                             this->data->location().getVisibility())\n    emit detailedWeatherDataFetched();\n}\n\n# This is the default widget for the weather page.\nweatherWidget = QWidgWidget()\n\n# The default widget for the weather page.\ndetailedWeatherWidget = QWidgWidget()\n\n# The default widget for the weather page.\ndailyWidget = QWidgWidget()\n\n# The default widget for the weather page.\nhourlyWidget = QWidgWidget()\n\n# The default widget for", "review_label": "1", "comment": "/"}, {"prefix": "import pandas as pd\nimport matplotlib.pyplot as plt\ndata = pd.read_csv('../dataset/preprocessed.csv')\ndata.head()", "middle": "data.drop(['Action'], axis=1, inplace=True)", "suffix": "feature_names = data.columns\ndata.head()\nfrom sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nscaler.fit(data)\ndata = scaler.transform(data)\nfrom sklearn.decomposition import PCA\npca = PCA(n_components=3)\npca.fit(data)\npca_names = [f'PCA_{i}' for i in range(pca.n_components_)]\nplt.matshow(pca.components_)\nplt.xticks(ticks=range(pca.components_.shape[1]),\n           labels=feature_names,\n           rotation='vertical')\nplt.yticks(ticks=range(pca.n_components_),\n           labels=pca_names)\nplt.colorbar()\nplt.show()\nplt.bar(x=pca_names,\n        height=pca.explained_variance_ratio_)\nplt.title('Udeo objasnjene varijanse svake od glavnih komponenti pojedinacno')\nplt.show()", "middle_predicted": "\n", "review_label": "1", "comment": "/"}, {"prefix": "QString Settings::temperatureUnitToApiParameter(const TemperatureUnit tempUnit) const\n{\n    switch (tempUnit) {\n    case Settings::TemperatureUnit::CELSIUS:\n        return \"celsius\";\n    case Settings::TemperatureUnit::FAHRENHEIT:\n        return \"fahrenheit\";\n    default:\n        return \"\";\n    }\n}\nQString Settings::windSpeedUnitToApiParameter(const WindSpeedUnit windSpeedUnit) const\n{\n    switch (windSpeedUnit) {\n    case Settings::WindSpeedUnit::KMH:\n        return \"kmh\";\n    case Settings::WindSpeedUnit::MPH:\n        return \"mph\";\n    case Settings::WindSpeedUnit::MS:\n        return \"ms\";\n    case Settings::WindSpeedUnit::KNOTS:\n        return \"kn\";\n    default:\n        return \"\";", "middle": "    }\n}\nQString Settings::temperatureUnitToString(const TemperatureUnit tempUnit) const", "suffix": "{\n    switch (tempUnit) {\n    case Settings::TemperatureUnit::CELSIUS:\n        return \"\u00b0C\";\n    case Settings::TemperatureUnit::FAHRENHEIT:\n        return \"\u00b0F\";\n    default:\n        return \"\";\n    }\n}\nQString Settings::precipitationUnitsNames(const PrecipitationUnit precUnit) const\n{\n    switch (precUnit) {\n    case Settings::PrecipitationUnit::MILLIMETRES:\n        return \"Millimetres\";\n    case Settings::PrecipitationUnit::INCHES:\n        return \"Inches\";\n    default:\n        return \"\";\n    }\n}", "middle_predicted": ";\n    }\n}\nQString Settings::pressureUnitsNames(const PressureUnit pressureUnit) const\n{\n    switch (pressureUnit) {\n    case Settings::PressureUnit::BAR:\n        return \"bar\";\n    case Settings::PressureUnit::CO2:\n        return \"co2\";\n    case Settings::PressureUnit::M3:\n        return \"m3\";\n    case Settings::PressureUnit::N2O:\n        return \"n2o\";\n    default:\n        return \"\";\n    }\n}\nQString Settings::humidityUnitsNames(const HumidityUnit humidityUnit) const\n{\n    switch (humidityUnit) {\n    case Settings::HumidityUnit::NONE:\n        return \"none", "review_label": "1", "comment": "/"}, {"prefix": "def simulated_annealing(orders: list[int],\n                        initial_temp: float = 100,\n                        min_temp: float = 1,\n                        alpha: float = None,\n                        max_iters: int = 5000,\n                        make_small_change: Callable[[list[int]], None] = swap,\n                        calc_temperature: Callable[[float, float], float] = calc_temperature_1,\n                        plot: bool = False,\n                        max_accepted_solutions: int = 2,\n                        sum_best_values: list[int] = None,\n                        sum_num_stocks: list[int] = None,\n                        sum_value_perc_improvement: list[float] = None,\n                        sum_num_stocks_perc_improvement: list[float] = None\n                        ) -> tuple[list[int], int, int]:\n    if alpha is None:\n        alpha = calc_alpha(initial_temp, min_temp, max_iters)\n    num_orders = len(orders)\n    solution = initialize(orders)", "middle": "    temperature = initial_temp\n    value, stocks_used = calc_solution_value(solution)\n    best_solution = deepcopy(solution)", "suffix": "    best_value = value\n    best_stocks_used = stocks_used\n    PLT_VALUES = []\n    PLT_STOCKS_USED = []\n    ITERS = 0\n    while temperature > min_temp and ITERS < max_iters:\n        accepted_solutions = 0\n        new_solution = deepcopy(solution)\n        make_small_change(new_solution)\n        new_value, new_stocks_used = calc_solution_value(new_solution)\n        diff = new_value - value\n        if diff <= 0:\n            solution = deepcopy(new_solution)\n            value = new_value\n            stocks_used = new_stocks_used\n            if new_value < best_value:\n                best_value = new_value\n                best_solution = deepcopy(new_solution)\n                best_stocks_used = new_stocks_used\n            accepted_solutions += 1    \n        elif random.random() < (math.e)**((-diff) / temperature):\n            value = new_value\n            solution = deepcopy(new_solution)\n            stocks_used = new_stocks_used\n            accepted_solutions += 1\n        if diff > 0 or accepted_solutions >= max_accepted_solutions:\n            temperature = calc_temperature(temperature, alpha)\n        PLT_VALUES.append(value)\n        PLT_STOCKS_USED.append(stocks_used)\n        ITERS += 1", "middle_predicted": "\n    for i in range(max_iters):\n        temp = initial_temp + (i * alpha)\n        solution = simulate(solution, temp)\n        if not make_small_change(solution):\n            break\n    return solution, temp\n\n\ndef calc_solution_value(solution: list[int]) -> tuple[float, list[int]]:\n    \"\"\"Calculate the value of a given solution.\"\"\"\n    value = solution[-1]\n    stocks_used = [stock for stock in", "review_label": "1", "comment": "/"}, {"prefix": "from scipy.cluster.hierarchy import dendrogram, linkage\nimport matplotlib.pyplot as plt\nattributes = ['PCA_1', 'PCA_2', 'PCA_3']\nfig, axs = plt.subplots(1, 3, figsize=(15, 5))\nfor i, attr in enumerate(attributes):\n    sampled_data = data.sample(n=100, random_state=42)\n    Z = linkage(sampled_data[attr].values.reshape(-1, 1), method='average')", "middle": "    ax = axs[i]\n    dendrogram(Z, leaf_rotation=90, no_labels=True, ax=ax)\n    ax.set_title(f'Dendrogram for {attr}')", "suffix": "    ax.set_xlabel('Data Points')\n    ax.set_ylabel('Distance')\nplt.tight_layout()\nplt.show()", "middle_predicted": "\n    fig.suptitle(\"Clustering for {} attribute\".format(attr))\n    ax = axs[i]\n    ", "review_label": "1", "comment": "/"}, {"prefix": "// Location info\n// --------------------------------------------------------------\nvoid LocationInfoWidget::updateData(const QGeoCoordinate &newCoordinates,", "middle": "                                    const QString &cityName, const QString &countryName)\n{\n    cityLabel->setText(cityName);", "suffix": "    countryLabel->setText(countryName);\n    coordinates = newCoordinates;\n}\nvoid DailyWeatherWidget::DailyWidgetItem::updateData(const QString &dayName, const int weatherCode,\n                                                     const int minTemp, const int maxTemp,\n                                                     const QVector<int> &temperatures)\n{\n    dayNameLabel->setText(dayName);\n    dayWeatherIcon.load(Settings::instance().weatherCodeToIcon(weatherCode, true));\n    dayWeatherIconLabel->setPixmap(dayWeatherIcon.scaled(iconWidth, iconHeight,\n                                                         Qt::KeepAspectRatio, Qt::SmoothTransformation));\n    dailyminTempLabel->setText(QString::number(minTemp) + \"\u00b0\");\n    dailymaxTempLabel->setText(QString::number(maxTemp) + \"\u00b0\");\n    temperatureDataForTheDay = temperatures;\n    dayNameString = dayName;\n}", "middle_predicted": " QPoint *coordinates)\n{\n    coordinates = newCoordinates;\n}\nvoid WeatherWidget::WeatherItem::updateData(const QString &name, const QString &code,\n                                                    const QString &minTemp, const QString &maxTemp,\n                                                    const QString &weatherIcon)\n{\n    nameLabel->setText(name);\n    codeLabel->setText(code);\n    minTempLabel->setText(minTemp);\n    maxTempLabel->setText(maxTemp);\n    weatherIconLabel->setPixmap(weatherIcon.scaled(iconWidth, iconHeight,\n                                                          Qt::KeepAspectRatio, Qt::SmoothTransformation));\n    weatherIconLabel->setScaledContents(True);\n    weatherIconLabel->setAlignment(Qt", "review_label": "1", "comment": "/"}, {"prefix": "from sklearn.feature_extraction.text import TfidfVectorizer\ndef tfidf(sequence, k):\n    kmers = get_kmers(str(sequence), k)\n    vectorizer = TfidfVectorizer()\n    X = vectorizer.fit_transform([kmers])\n    tfidf_matrix = X.toarray()\n    return tfidf_matrix, vectorizer\ndef get_kmers(sequence, k):\n    kmers = [sequence[i:i+k] for i in range(len(sequence) - k + 1)]\n    return ' '.join(kmers)\ndef get_kmers_map(tfidf_matrix, vectorizer, sequence, top_n=20):\n    feature_names = vectorizer.get_feature_names_out()\n    feature_scores = tfidf_matrix.flatten()\n    top_kmers_indices = feature_scores.argsort()[-top_n:][::-1]", "middle": "    top_kmers = [(feature_names[i], feature_scores[i]) for i in top_kmers_indices]\n    mapped_kmers = {}", "suffix": "    for kmer, score in top_kmers:\n        kmer = kmer.upper()\n        count = sequence.count(kmer)\n        mapped_kmers[kmer] = {'score': score, 'count': count}\n    return mapped_kmers\ndef find_unique_kmers(full_sequence, start_index, end_index, significant_kmers, unique_kmers):\n    for kmer, details in significant_kmers.items():\n        left_occurrences = full_sequence[:start_index].count(kmer)\n        right_occurrences = full_sequence[end_index:].count(kmer)\n        occurrences = left_occurrences + right_occurrences\n        if occurrences == 0:\n            unique_kmers.append((kmer, details['count']))", "middle_predicted": "\n    top_kmers = []\n    for index in top_kmers_indices:\n        top_kmers.append({'name': feature_names[index],'score': feature_scores[index]})\n", "review_label": "4", "comment": "The code wouldn't work because mapped_kmers isn't initialized, but besides that the behaviour would stay the same"}, {"prefix": "void HomePage::updateCompleter(const QList<GeoLocationData>& locations)\n{\n    this->locations = locations;\n    QStringList places;\n    for (const auto& location : locations) {\n        places.append(location.getDetailedPlace());\n    }\n    if (completer->model() != nullptr) {\n        delete completer->model();\n    }\n    completer->setModel(new QStringListModel(places, completer));\n    completer->complete();\n}\nvoid HomePage::onCompletionActivated(const QString& text)\n{\n    for (const auto& location : locations) {\n        if (location.getDetailedPlace() == text) {\n            emit locationObjectSelected(location);", "middle": "            break;", "suffix": "        }\n    }\n    searchBar->clear();\n    delete completer->model();\n    completer->setModel(new QStringListModel());\n    completer->complete();\n}", "middle_predicted": "\n        }\n    }\n    searchBar->clear();\n    delete completer->model();\n    completer->setModel(new QStringListModel());\n    completer->complete();\n}\nvoid HomePage::onSelectionChanged(const QString& selection)\n{\n    for (const auto& location : locations) {\n        if (location.getDetailedPlace() == selection) {\n    ", "review_label": "1", "comment": "/"}, {"prefix": "void SettingsDialog::changeSettings()\n{\n    Settings::TemperatureUnit selectedTempUnit = static_cast<Settings::TemperatureUnit>(temperatureUnit->itemData(temperatureUnit->currentIndex()).toInt());\n    Settings::WindSpeedUnit selectedWindUnit= static_cast<Settings::WindSpeedUnit>(windSpeedUnit->itemData(windSpeedUnit->currentIndex()).toInt());\n    Settings::PrecipitationUnit selectedPrecUnit = static_cast<Settings::PrecipitationUnit>(precipitationUnit->itemData(precipitationUnit->currentIndex()).toInt());\n    for (int i = 0; i < listWidget->count(); i++) {\n        auto locationMap = listWidget->item(i)->data(Qt::UserRole).toMap();\n        auto geoLocation = GeoLocationData::fromVariantMap(locationMap);\n        QString newLocationName = listWidget->itemWidget(listWidget->item(i))->findChild<QLineEdit *>()->text();\n        geoLocation.setRenamedPlace(newLocationName);\n        auto iter = std::find(widgetOrder.begin(), widgetOrder.end(), geoLocation);", "middle": "        if (iter != widgetOrder.end()) {\n            *iter = geoLocation;\n        }", "suffix": "    }\n    settings.m_temperatureUnit = selectedTempUnit;\n    settings.m_windSpeedUnit = selectedWindUnit;\n    settings.m_precipitationUnit = selectedPrecUnit;\n    settings.m_shareLocation = locationSwitch->isChecked();\n    settings.m_savedLocations = widgetOrder;\n    emit settingsChanged();\n    this->close();\n}", "middle_predicted": "\n        if (iter!= -1) {\n            auto iter = iter + 1;\n    ", "review_label": "1", "comment": "/"}, {"prefix": "def mutation_swap(instance):\n    pos1 = random.randrange(len(instance.code))\n    pos2 = random.randrange(len(instance.code))\n    while pos2 == pos1:\n        pos2 = random.randrange(len(instance.code))\n    tmp = instance.code[pos1]\n    instance.code[pos1] = instance.code[pos2]", "middle": "    instance.code[pos2] = tmp\ndef mutation_insert(instance):\n    pos1 = random.randrange(len(instance.code))", "suffix": "    pos2 = random.randrange(len(instance.code))\n    while pos2 == pos1:\n        pos2 = random.randrange(len(instance.code))\n    element = instance.code.pop(pos1)\n    instance.code.insert(pos2, element)\ndef mutation_inverse(instance):\n    pos1 = random.randrange(len(instance.code))\n    pos2 = random.randrange(len(instance.code))\n    while pos2 == pos1:\n        pos2 = random.randrange(len(instance.code))\n    if pos1 > pos2:\n        pos1,pos2 = pos2,pos1\n    instance.code[pos1:pos2 + 1] = instance.code[pos1:pos2 + 1][::-1]", "middle_predicted": "\n    instance.code[pos2] = tmp\n\n\ndef mutation_add(instance):\n    pos1 = random.randrange(len(instance.code))\n    ", "review_label": "5", "comment": "Function name isn't the same, but the code would work perfectly"}, {"prefix": "import pandas as pd\nfrom matplotlib import pyplot as plt\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.tree import DecisionTreeClassifier, plot_tree\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import classification_report\nfrom termcolor import colored\ndata = pd.read_csv('../dataset/preprocessed.csv')\ndata.head()\nY = data['Action']\nX = data.drop(['Action'], axis=1)\nfeature_names = X.columns.tolist()\nX.head()\nX_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.25, stratify=Y, random_state=42)\nfrom sklearn.model_selection import GridSearchCV\nparam_grid = {\n    'criterion': ['gini', 'entropy'],\n    'max_depth': [12,15,18,20,None],", "middle": "    'min_samples_split': [2, 5, 10],\n    'min_samples_leaf': [1, 2, 4],", "suffix": "    'splitter': ['best', 'random']\n}\nestimator = GridSearchCV(DecisionTreeClassifier(class_weight='balanced'), param_grid=param_grid, cv=3)\nestimator.fit(X_train, Y_train)\nprint(estimator.best_params_, '\n')\nprint(estimator.best_score_)\nreport(estimator.best_estimator_, X_train, Y_train)\nreport(estimator.best_estimator_, X_test, Y_test, \"test\")\nplot_decision_tree(estimator.best_estimator_, feature_names)", "middle_predicted": "\n   'min_samples_leaf': range(1, 6),\n  'min_samples_split': range(1, 7),\n    'bootstrap': [True, False]\n", "review_label": "1", "comment": "/"}, {"prefix": "from sklearn.cluster import AgglomerativeClustering\nfrom sklearn.metrics import silhouette_score\nsilhouette_scores = [[],[],[]]\nn_clusters_list = range(2,6)\nlinkages = ['single', 'complete', 'average']\nfig = plt.figure(figsize=(15, 15))\nfor n_clusters in n_clusters_list:\n    for idx, linkage in enumerate(linkages):\n        model = AgglomerativeClustering(n_clusters=n_clusters, linkage=linkage)\n", "middle": "        model.fit(data)", "suffix": "\n        ax = fig.add_subplot(len(n_clusters_list), len(linkages), (n_clusters_list.index(n_clusters) * len(linkages)) + idx + 1, projection='3d')\n        for cluster_label in range(n_clusters):\n            cluster = data[model.labels_ == cluster_label]\n            ax.scatter(cluster['PCA_1'], cluster['PCA_2'], cluster['PCA_3'], label=f'Cluster {cluster_label}')\n        ax.set_title(f'n_clusters: {n_clusters}, Linkage: {linkage}')\n        ax.legend()\n        silhouette_scores[idx].append(silhouette_score(data, model.labels_))\nplt.show()", "middle_predicted": "    data = pd.DataFrame(model.fit_predict(X).reshape(-1, 1)).T", "review_label": "1", "comment": "/"}, {"prefix": "def plot_clusters(data, centers, labels, feature_names, alg_name):\n    fig, axes = plt.subplots(1, 2, figsize=(12, 6), subplot_kw={'projection': '3d'})\n    # First plot\n    ax = axes[0]\n    ax.scatter(centers[:, 0], centers[:, 1], centers[:, 2], marker='X', label='centroids', color=\"black\")\n    for c in np.unique(labels):\n        elems = data[labels == c]\n        ax.scatter(elems[feature_names[0]], elems[feature_names[1]], elems[feature_names[2]], label=c)\n    ax.set_xlabel(feature_names[0])\n    ax.set_ylabel(feature_names[1])\n    ax.set_zlabel(feature_names[2])\n    ax.set_title('{} {} clusters (View 1)'.format(alg_name, len(centers)))\n    ax.legend()\n    # Second plot\n    ax = axes[1]\n    ax.scatter(centers[:, 0], centers[:, 1], centers[:, 2], marker='X', label='centroids', color=\"black\")\n    for c in np.unique(labels):\n        elems = data[labels == c]", "middle": "        ax.scatter(elems[feature_names[0]], elems[feature_names[1]], elems[feature_names[2]], label=c)", "suffix": "    ax.set_xlabel(feature_names[0])\n    ax.set_ylabel(feature_names[1])\n    ax.set_zlabel(feature_names[2])\n    ax.view_init(azim=60)\n    ax.set_title('{} {} clusters (View 2)'.format(alg_name, len(centers)))\n    ax.legend()\n    plt.tight_layout()\n    plt.show()", "middle_predicted": "\n        ax.scatter(elems[feature_names[0]], elems[feature_names[1]], elems[feature_names[2]], label=c)\n", "review_label": "5", "comment": "/"}, {"prefix": "def tournament_selection(population, forbidden):\n    allowed = list(set(population).difference({forbidden}))\n    chosen = random.sample(allowed, TOURNAMENT_SIZE)\n    return min(chosen, key=lambda x: x.fitness)\ndef roulette_selection(population, forbidden):    \n    allowed = list(set(population).difference({forbidden}))\n    allowed.sort(key=lambda x: x.fitness)\n    fitness_sum = sum([a.fitness for a in allowed])\n    probs = [a.fitness / fitness_sum for a in allowed]\n    probs.reverse()\n    return np.random.choice(allowed, p=probs)\ndef rank_selection(population, forbidden):    \n    allowed = list(set(population).difference({forbidden}))", "middle": "    allowed.sort(key=lambda x: x.fitness)\n    n = len(allowed)\n    probs = [0 for i in range(n)]", "suffix": "    for i, individual in enumerate(allowed):\n        probs[i] = (1 / n) * ( (SELECTION_PRESSURE - (2 * SELECTION_PRESSURE - 2) * ( i / (n - 1))) )\n    return np.random.choice(allowed, p=probs)", "middle_predicted": "\n    allowed.sort(key=lambda x: x.fitness)\n    fitness_sum = sum([a.fitness for a in allowed])\n    ranks = [a.rank for a in allowed]\n    ranks.reverse()\n    return np.random.choice(allowed, p=ranks)\ndef selection_probability(population, forbidden):\n    allowed = list(set(population).difference({forbidden}))\n    allowed.sort(key=lambda x: x.fitness)\n    probs = [a.fitness / fitness_sum for a in allowed]\n", "review_label": 2, "comment": "It gets some structure right but diverges from what the real code is doing"}, {"prefix": "def to_spmf_format(genome_sequence):\n    seq = str(genome_sequence)\n    seq = seq.replace('A', '1')\n    seq = seq.replace('C', '2')\n    seq = seq.replace('G', '3')\n    seq = seq.replace('T', '4')\n    seq = ''.join(c + ' -1 ' for c in seq).rstrip(' -1 ') + ' -2'\n    return seq", "middle": "def from_spmf_format(filename):", "suffix": "    patterns = []\n    with open(filename, 'r') as file:\n        for line in file:\n            lst = line.split('#')\n            pattern = lst[0]\n            support = lst[1]\n            pattern = pattern.replace('-1', '')\n            pattern = pattern.replace('1', 'A')\n            pattern = pattern.replace('2', 'C')\n            pattern = pattern.replace('3', 'G')\n            pattern = pattern.replace('4', 'T')\n            pattern = pattern.replace(' ', '')\n            support = int(support.replace('SUP: ', ''))\n            patterns.append((pattern, support))\n    return patterns", "middle_predicted": "\n\n\ndef get_patterns(filename):\n", "review_label": "4", "comment": "/"}, {"prefix": "bool Character::isOnPoint(float x, float z, float delta){", "middle": "    return(characterPosition.x > x-delta && characterPosition.x < x+delta\n", "suffix": "           && characterPosition.z > z-delta && characterPosition.z < z + delta);\n}", "middle_predicted": "", "review_label": "1", "comment": "/"}]